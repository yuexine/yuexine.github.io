{"pages":[],"posts":[{"title":"TCP与UDP","text":"传输层的作用作为传输层的两个主要协议，为了识别自己传输的数据属于哪个应用，在协议内设定了端口号 将接收和发送的数据与特定的应用程序进行关联起来,通过socket，也就是绑定了端口 区别 TCP 是面向连接的，可靠的的流协议，它提供了可靠性传输，实行顺序控制`重发控制流量控制拥塞控制提高网络利用率`等多种功能 UDP 是不具有可靠性的数据报协议，细微的处理交给上层的应用去完成 TCP头部就不解释每个字段的意思了 TCP的特点1. 通过序列号和确认应答提高可靠性 2. 数据包丢失 数据无法到达 数据应答丢失 3. 重发的超时时间如何确定在BSD的Unix以及Windows系统中，超时都是以0.5s为单位进行控制的，因此重发超时的都是0.5的整数倍，不过由于最初的数据包还不知道往返时间，所以其重发的超时一般设置在6s左右。 4. 连接管理这个会经常提到 5. TCP以段发送数据在建立TCP连接的同时，也可以确定发送数据包的单位，称为最大消息长度（MSS），TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。 6. 利用窗口控制提高速度TCP以1个段为单位，每发一个段进行一次确认应答，性能太差了，为了解决这个问题。 确认应答不再是以每个分段，而是以更大的单位进行确认，转发的时间被大幅度缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送 7. 窗口控制与重发控制 8. 流控制为了防止流量浪费，比如说，数据接收端在高负荷的情况下无法接受任何数据。如果将本来接受的数据丢弃，则会触发重发机制。 为了防止这种现象，TCP提供了一种机制可以让发送端根据接收端的实际接受能力控制发送的数据量。这就是流控制。 做法就是在TCP首部中，有一个字段来通知窗口的大小，值越大，吞吐量越高 9. 拥塞控制慢启动，慢慢变快 10. 捎带应答 UDP头部","link":"/2019/05/08/TCP与UDP/"},{"title":"Spring Cloud Config Server","text":"功能 基于rest形式提供额外的配置（键值对或yaml文本） 配置值的加解密（对称或非对称） 与springboot集成简单 环境仓库你的配置数据应该存放在哪里？Spring Cloud Config提供了多种策略，比如可以是filesystem，git，vault等，这里我们使用git管理我们的配置数据 Config Server如何做到管理应用的多个环节配置呢，它主要是用了以下三个变量来对配置数据进行区分 {application} 对应到客户端的spring.application.name {profile} 对应到客户端spring.application.profile {label} 这是服务端标记版本化的配置文件集合 这样客户端spring boot应用在启动的时候通过指定应用启动的参数，从而获取对应的配置数据 一个客户端应用程序引导配置示例 12345spring: application: name: foo profiles: active: dev，mysql 使用git作为存储库的一些配置 123456789101112spring: cloud: config: server: git: uri: https：//example.com/my/{application} # 占位符 skipSslValidation: true # 跳过ssl证书验证，默认false timeout: 4 # 超时时间（秒） username: user password: pw # 配置认证 searchPaths: '{application}' # 带占位符的搜索路径 refreshRate: 0 # 刷新频率，0表示每次请求都会获取最新的配置 健康指标Config Server附带一个运行状况指示器，用于检查配置EnvironmentRepository是否正常，默认情况下指示器请求的{application}是app，{profile}是default 配置健康指示器 1234567891011spring: cloud: config: server: health: repositories: myservice: label: mylabel myservice-dev: name: myservice profiles: development 如果想要禁用健康检查需要设置 spring.cloud.config.server.health.enabled=false 另外在配置健康检查之后，如果需要获取详细的健康指标数据还需要做额外的配置 12345678management: endpoints: enabled-by-default: true web: base-path: /admin endpoint: health: show-details: always # 显示详细数据 安全通过集成spring-boot-starter-security使用默认的HTTP Basic来保护配置数据 配置用户名密码 12345spring: security: user: name: yuexin password: XXX 加密与解密不想看了，用的时候再去看文档 附上完整的配置 123456789101112131415161718192021222324252627282930spring: application: name: clivia-config-server cloud: config: server: git: uri: https://github.com/yuexine/cloud-repo.git username: yuexine password: XXX search-paths: clivia health: repositories: cloud-repo: name: foo profiles: dev security: user: name: yuexin password: XXXserver: port: 8888management: endpoints: enabled-by-default: true web: base-path: /admin endpoint: health: show-details: always 参考: 官方文档-基于版本2.1.0.RELEASE Spring cloud config Actuator健康监测","link":"/2019/05/06/Spring-Cloud-Config-Server/"},{"title":"Spring Cloud Eureka Client","text":"使用Eureka Client在pom中包含jar 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 注册指定注册中心的位置 1234eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 注册认证HTTP Basic认证已经自动添加到eureka客户端中, 更复杂的需求，参考文档实现 1http://user:password@localhost:8761/eureka 源码分析在阅读源码的时候，我们根据它本身提供的功能去关注它实现的过程，以及代码是怎么被触发的 入口 通过观察spring-cloud-netflix-eureka-client包中的META-INF/spring.factories可以看到里面配置了一组EnableAutoConfiguration, 我们重点关注EurekaClientAutoConfiguration EurekaClientAutoConfiguration 在这个对象中，主要是根据条件创建了一组spring bean, 包括 EurekaClientConfigBean ManagementMetadataProvider EurekaInstanceConfigBean DiscoveryClient EurekaServiceRegistry EurekaClient EurekaClient 继续跟踪代码，观察EurekaClient的初始化过程 1234567891011121314 public class CloudEurekaClient extends DiscoveryClient { ... public CloudEurekaClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs&lt;?&gt; args, ApplicationEventPublisher publisher) { super(applicationInfoManager, config, args); this.applicationInfoManager = applicationInfoManager; this.publisher = publisher; this.eurekaTransportField = ReflectionUtils.findField(DiscoveryClient.class, \"eurekaTransport\"); ReflectionUtils.makeAccessible(this.eurekaTransportField); } ...} 这里会调用父级的构造方法去执行注册、心跳、缓存刷新等任务 1234567891011121314151617181920212223242526272829 DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) { ... // default size of 2 - 1 each for heartbeat and cacheRefresh scheduler = Executors.newScheduledThreadPool(2, new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-%d\") .setDaemon(true) .build()); heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-HeartbeatExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-CacheRefreshExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff ... } 到这里我们可以发现，spring cloud eureka client将这些任务都委托给了Netflix的Eureka组建去执行","link":"/2019/05/08/Spring-Cloud-Eureka-Client/"},{"title":"Jenkins集成Helm进行应用持续发布","text":"目标 在开发过程中，对开发的应用版本进行持续迭代并且发布到kubernetes集群中 使用Helm工具以chart升级的方式完成不同版本应用的发布升级 前提 在使用Helm之前，已经完成了Jenkins的部署，并且已经正常运行脚本与Kubernetes平台进行 通过kubectl命令执行配置文件完成应用的版本更新 实现步骤 helm chart制作，此步骤略 包含helm工具的jenkins容器镜像制作 制作完成的镜像文件 harbor.3incloud.com/library/jenkins-jnlp:latest 初始化应用安装 helm init --client-only &amp;&amp; helm repo add --username jenkins --password password myharbor https://harbor.3incloud.com/chartrepo/XXXX &amp;&amp; helm repo update 这里主要就是在slave中初始化helm，并且添加私有的chart仓库 Jenkins完成应用持续部署 helm upgrade --reuse-values --set-string image.tag='${build_tag}' deploy-name --version 0.1.0 myharbor/chart-name 通过重新设定chart的image.tag完成容器的版本升级，--reuse-values 表示在原本参数的基础上进行更新 完整的Pipeline脚本123456789101112131415161718192021222324252627node('worker') { stage('Clone') { echo \"1.Clone Stage\" git credentialsId: 'gitlab-auth', url: 'https://gitlab.3incloud.com/xxx/xxx-server.git' script { build_tag = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim() } } stage('Test') { echo \"2.Test Stage\" } stage('Build') { echo \"3.Build Docker Image Stage\" sh \"docker build -t harbor.3incloud.com/xxx/xxx-server:${build_tag} .\" } stage('Push') { echo \"4.Push Docker Image Stage\" withDockerRegistry(credentialsId: 'harbor-ci', url: 'https://harbor.3incloud.com') { sh \"docker push harbor.3incloud.com/xxx/xxx-server:${build_tag}\" } } stage('Deploy') { echo \"5. Deploy Stage\" sh \"helm init --client-only &amp;&amp; helm repo add --username jenkins --password password myharbor https://harbor.3incloud.com/chartrepo/xxx &amp;&amp; helm repo update\" sh \"helm upgrade --reuse-values --set-string image.tag='${build_tag}' avic-server --version 0.1.0 myharbor/xxx-server\" }}","link":"/2019/04/25/Jenkins集成Helm进行应用持续发布/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/24/hello-world/"}],"tags":[{"name":"network","slug":"network","link":"/tags/network/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"helm","slug":"helm","link":"/tags/helm/"}],"categories":[{"name":"ComputerNetwork","slug":"ComputerNetwork","link":"/categories/ComputerNetwork/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","link":"/categories/Spring/SpringCloud/"},{"name":"Jenkins","slug":"DevOps/Jenkins","link":"/categories/DevOps/Jenkins/"}]}