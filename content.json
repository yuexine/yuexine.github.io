{"pages":[],"posts":[{"title":"Jenkins集成Helm进行应用持续发布","text":"目标 在开发过程中，对开发的应用版本进行持续迭代并且发布到kubernetes集群中 使用Helm工具以chart升级的方式完成不同版本应用的发布升级 前提 在使用Helm之前，已经完成了Jenkins的部署，并且已经正常运行脚本与Kubernetes平台进行 通过kubectl命令执行配置文件完成应用的版本更新 实现步骤 helm chart制作，此步骤略 包含helm工具的jenkins容器镜像制作 制作完成的镜像文件 harbor.3incloud.com/library/jenkins-jnlp:latest 初始化应用安装 helm init --client-only &amp;&amp; helm repo add --username jenkins --password password myharbor https://harbor.3incloud.com/chartrepo/XXXX &amp;&amp; helm repo update 这里主要就是在slave中初始化helm，并且添加私有的chart仓库 Jenkins完成应用持续部署 helm upgrade --reuse-values --set-string image.tag='${build_tag}' deploy-name --version 0.1.0 myharbor/chart-name 通过重新设定chart的image.tag完成容器的版本升级，--reuse-values 表示在原本参数的基础上进行更新 完整的Pipeline脚本123456789101112131415161718192021222324252627node('worker') { stage('Clone') { echo \"1.Clone Stage\" git credentialsId: 'gitlab-auth', url: 'https://gitlab.3incloud.com/xxx/xxx-server.git' script { build_tag = sh(returnStdout: true, script: 'git rev-parse --short HEAD').trim() } } stage('Test') { echo \"2.Test Stage\" } stage('Build') { echo \"3.Build Docker Image Stage\" sh \"docker build -t harbor.3incloud.com/xxx/xxx-server:${build_tag} .\" } stage('Push') { echo \"4.Push Docker Image Stage\" withDockerRegistry(credentialsId: 'harbor-ci', url: 'https://harbor.3incloud.com') { sh \"docker push harbor.3incloud.com/xxx/xxx-server:${build_tag}\" } } stage('Deploy') { echo \"5. Deploy Stage\" sh \"helm init --client-only &amp;&amp; helm repo add --username jenkins --password password myharbor https://harbor.3incloud.com/chartrepo/xxx &amp;&amp; helm repo update\" sh \"helm upgrade --reuse-values --set-string image.tag='${build_tag}' avic-server --version 0.1.0 myharbor/xxx-server\" }}","link":"/2019/04/25/Jenkins集成Helm进行应用持续发布/"},{"title":"Spring Cloud Config Server","text":"功能 基于rest形式提供额外的配置（键值对或yaml文本） 配置值的加解密（对称或非对称） 与springboot集成简单 环境仓库你的配置数据应该存放在哪里？Spring Cloud Config提供了多种策略，比如可以是filesystem，git，vault等，这里我们使用git管理我们的配置数据 Config Server如何做到管理应用的多个环节配置呢，它主要是用了以下三个变量来对配置数据进行区分 {application} 对应到客户端的spring.application.name {profile} 对应到客户端spring.application.profile {label} 这是服务端标记版本化的配置文件集合 这样客户端spring boot应用在启动的时候通过指定应用启动的参数，从而获取对应的配置数据 一个客户端应用程序引导配置示例 12345spring: application: name: foo profiles: active: dev，mysql 使用git作为存储库的一些配置 123456789101112spring: cloud: config: server: git: uri: https：//example.com/my/{application} # 占位符 skipSslValidation: true # 跳过ssl证书验证，默认false timeout: 4 # 超时时间（秒） username: user password: pw # 配置认证 searchPaths: '{application}' # 带占位符的搜索路径 refreshRate: 0 # 刷新频率，0表示每次请求都会获取最新的配置 健康指标Config Server附带一个运行状况指示器，用于检查配置EnvironmentRepository是否正常，默认情况下指示器请求的{application}是app，{profile}是default 配置健康指示器 1234567891011spring: cloud: config: server: health: repositories: myservice: label: mylabel myservice-dev: name: myservice profiles: development 如果想要禁用健康检查需要设置 spring.cloud.config.server.health.enabled=false 另外在配置健康检查之后，如果需要获取详细的健康指标数据还需要做额外的配置 12345678management: endpoints: enabled-by-default: true web: base-path: /admin endpoint: health: show-details: always # 显示详细数据 安全通过集成spring-boot-starter-security使用默认的HTTP Basic来保护配置数据 配置用户名密码 12345spring: security: user: name: yuexin password: XXX 加密与解密不想看了，用的时候再去看文档 附上完整的配置 123456789101112131415161718192021222324252627282930spring: application: name: clivia-config-server cloud: config: server: git: uri: https://github.com/yuexine/cloud-repo.git username: yuexine password: XXX search-paths: clivia health: repositories: cloud-repo: name: foo profiles: dev security: user: name: yuexin password: XXXserver: port: 8888management: endpoints: enabled-by-default: true web: base-path: /admin endpoint: health: show-details: always 参考: 官方文档-基于版本2.1.0.RELEASE Spring cloud config Actuator健康监测","link":"/2019/05/06/Spring-Cloud-Config-Server/"},{"title":"Spring Cloud Eureka Client","text":"使用Eureka Client在pom中包含jar 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 注册指定注册中心的位置 1234eureka: client: serviceUrl: defaultZone: http://localhost:8761/eureka/ 注册认证HTTP Basic认证已经自动添加到eureka客户端中, 更复杂的需求，参考文档实现 1http://user:password@localhost:8761/eureka 源码分析在阅读源码的时候，我们根据它本身提供的功能去关注它实现的过程，以及代码是怎么被触发的 入口 通过观察spring-cloud-netflix-eureka-client包中的META-INF/spring.factories可以看到里面配置了一组EnableAutoConfiguration, 我们重点关注EurekaClientAutoConfiguration EurekaClientAutoConfiguration 在这个对象中，主要是根据条件创建了一组spring bean, 包括 EurekaClientConfigBean ManagementMetadataProvider EurekaInstanceConfigBean DiscoveryClient EurekaServiceRegistry EurekaClient EurekaClient 继续跟踪代码，观察EurekaClient的初始化过程 1234567891011121314 public class CloudEurekaClient extends DiscoveryClient { ... public CloudEurekaClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs&lt;?&gt; args, ApplicationEventPublisher publisher) { super(applicationInfoManager, config, args); this.applicationInfoManager = applicationInfoManager; this.publisher = publisher; this.eurekaTransportField = ReflectionUtils.findField(DiscoveryClient.class, \"eurekaTransport\"); ReflectionUtils.makeAccessible(this.eurekaTransportField); } ...} 这里会调用父级的构造方法去执行注册、心跳、缓存刷新等任务 1234567891011121314151617181920212223242526272829 DiscoveryClient(ApplicationInfoManager applicationInfoManager, EurekaClientConfig config, AbstractDiscoveryClientOptionalArgs args, Provider&lt;BackupRegistry&gt; backupRegistryProvider) { ... // default size of 2 - 1 each for heartbeat and cacheRefresh scheduler = Executors.newScheduledThreadPool(2, new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-%d\") .setDaemon(true) .build()); heartbeatExecutor = new ThreadPoolExecutor( 1, clientConfig.getHeartbeatExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-HeartbeatExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff cacheRefreshExecutor = new ThreadPoolExecutor( 1, clientConfig.getCacheRefreshExecutorThreadPoolSize(), 0, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), new ThreadFactoryBuilder() .setNameFormat(\"DiscoveryClient-CacheRefreshExecutor-%d\") .setDaemon(true) .build() ); // use direct handoff ... } 到这里我们可以发现，spring cloud eureka client将这些任务都委托给了Netflix的Eureka组建去执行","link":"/2019/05/08/Spring-Cloud-Eureka-Client/"},{"title":"Spring Cloud Eureka Server","text":"运行Eureka Server将Eureka Server集成到应用中，只需要在pom中加入 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 接着在启动类上加入@EnableEurekaServer 最后配置application.yml 1234567891011server: port: 8761eureka: instance: hostname: localhost client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka/ 高可用在生产环境下，往往会部署多个eureka实例，使它们相互注册，实现的方式是通过修改配置实现 12345678910111213141516171819---spring: profiles: peer1eureka: instance: hostname: peer1 client: serviceUrl: defaultZone: http://peer2/eureka/---spring: profiles: peer2eureka: instance: hostname: peer2 client: serviceUrl: defaultZone: http://peer1/eureka/ 这样客户端在使用的时候，在指定注册中心时，指定多个，用逗号隔开 1234eureka: client: serviceUrl: defaultZone: http://peer1/eureka/,http://peer2/eureka 安全的 Eureka Server通过加入spring-boot-starter-security，使服务的注册与发现操作开启认证。 禁用CSRF 123456789@EnableWebSecurityclass WebSecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.csrf().ignoringAntMatchers(\"/eureka/**\"); super.configure(http); }} 在配置中加入 12345spring: security: user: name: admin password: pwd 修改defaultZone，指定name&amp;password，这里需要注意的是，所有的配置defaultZone的地方都需要配置name&amp;password，包括Eureka Server本身 123456789eureka: instance: hostname: localhost prefer-ip-address: true # 这里使用ip而不是默认的hostname client: registerWithEureka: false fetchRegistry: false serviceUrl: defaultZone: http://admin:pwd@${eureka.instance.hostname}:${server.port}/eureka/","link":"/2019/05/09/Spring-Cloud-Eureka-Server/"},{"title":"Spring Cloud OpenFeign","text":"理解OpenFeign它声明一个REST客户端，来完成远程服务的调用，Feign会动态实现由JAX-RS或Spring MVC注解修饰的接口，主要用途是用来简化服务之间的相互调用 在SpringBoot中集成Feign前提已经准备好由SpringBoot构建的客户端和服务端，并且已经成功注册到Eureka注册中心。 引入相关jar在客户端中Pom中加入 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;io.github.openfeign&lt;/groupId&gt; &lt;artifactId&gt;feign-okhttp&lt;/artifactId&gt;&lt;/dependency&gt; 相关配置在客户端启动类上加上注解@EnableFeignClients 使用声明一个接口，在接口的方法上引入SpringMvc的注解，即可完成远程服务的调用 123456@FeignClient(name = \"clivia-service-notification-${spring.profiles.active}\")public interface NotificationClient { @RequestMapping(method = RequestMethod.GET, value = \"/\") String home();} 使用Feign使用OKHTTP前面在引入jar包的时候，已经集成了okhttp相关的包 在理解这一块内容的时候，简单看了一下这一块的实现，根据官方的文档介绍 Spring Cloud Netflix提供了一些Bean，包括了Feign Client，在Ribbon开启的情况下，默认的FeignClient是LoadBalancerFeignClient 跟踪LoadBalancerFeignClient代码，它在构造器上定义了一个委派的Client,继续看这个对象。他的实现在接口内，并且最终使用的是HttpURLConnection, 也就是Java原生的远程连接对象。 回到主题，在这个包中，有一个配置类对象OkHttpFeignLoadBalancedConfiguration，开启条件是feign.okhttp.enabled=true，并且OkHttpClient存在于classpath中 继续观察当前对象 123456789101112131415161718192021222324252627282930313233343536373839404142@Configuration@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)protected static class OkHttpFeignConfiguration { private okhttp3.OkHttpClient okHttpClient; &lt;!--定义了一个连接池--&gt; @Bean @ConditionalOnMissingBean(ConnectionPool.class) public ConnectionPool httpClientConnectionPool( FeignHttpClientProperties httpClientProperties, OkHttpClientConnectionPoolFactory connectionPoolFactory) { Integer maxTotalConnections = httpClientProperties.getMaxConnections(); Long timeToLive = httpClientProperties.getTimeToLive(); TimeUnit ttlUnit = httpClientProperties.getTimeToLiveUnit(); return connectionPoolFactory.create(maxTotalConnections, timeToLive, ttlUnit); } &lt;!--创建了一个OkHttpClient客户端--&gt; @Bean public okhttp3.OkHttpClient client(OkHttpClientFactory httpClientFactory, ConnectionPool connectionPool, FeignHttpClientProperties httpClientProperties) { Boolean followRedirects = httpClientProperties.isFollowRedirects(); Integer connectTimeout = httpClientProperties.getConnectionTimeout(); this.okHttpClient = httpClientFactory .createBuilder(httpClientProperties.isDisableSslValidation()) .connectTimeout(connectTimeout, TimeUnit.MILLISECONDS) .followRedirects(followRedirects).connectionPool(connectionPool) .build(); return this.okHttpClient; } @PreDestroy public void destroy() { if (this.okHttpClient != null) { this.okHttpClient.dispatcher().executorService().shutdown(); this.okHttpClient.connectionPool().evictAll(); } } } 通过对以上代码的理解，我只需要在配置中设置feign.okhttp.enabled=true，即可使用OkHttp作为服务调用的客户端工具，当然，如果在代码中自己配置了OkHttpClientBean，框架本身就不会再重复创建了，相关连接池的配置读取自配置feign.httpclient.* 最后还需要注意的就是设置Feign客户端远程调用的连接和读取的超时时间配置，这个配置需要在客户端中额外配置，默认的配置示例 1234567feign: client: config: default: # 客户端名称，default表示默认 connectTimeout: 6000 readTimeout: 6000 # 表示6s loggerLevel: basic 通过修改OKHttp连接池和请求相应相关的参数来获取更好的性能 日志配置Feign日志记录仅响应DEBUG级别日志，所以首先配置Feign Client的日志级别为DEBUG 123logging: level: com.vcors.project.common.feign.NotificationClient: DEBUG 接下来配置Logger.Level，这里可以单独为每个客户端配置，也可以统一配置，下面的示例是配置到一个class中 123456789@Configurationpublic class FooConfiguration { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.FULL; }}@FeignClient(name = \"clivia-service-notification-${spring.profiles.active}\", configuration = {DefaultFeignConfiguration.class}) 日志级别 None 无日志，默认 BASIC 记录请求URL和方法及响应时间和状态 HEADERS 记录基本信息及请求响应头 FULL 记录全部的信息 数据压缩通过GZIP压缩请求 1234567feign: compression: request: enabled: true min-request-size: 2048 response: enabled: true HTTP BASIC认证对服务的API增加访问保护，是非常有意义的，被请求的服务通过集成spring-boot-starter-security, 可以快速使用HTTP BASIC 这个时候Feign在调用远程服务的时候，通过加入拦截器，可以完成HTTP BASIC的验证 12345678910111213141516171819@Configurationpublic class DefaultFeignConfiguration { @Bean Logger.Level feignLoggerLevel() { return Logger.Level.BASIC; } &lt;!--请求重试--&gt; @Bean Retryer feignRetryer() { return Retryer.NEVER_RETRY; } @Bean public BasicAuthRequestInterceptor basicAuthRequestInterceptor() { return new BasicAuthRequestInterceptor(\"admin\", \"passwd\"); }}","link":"/2019/05/09/Spring-Cloud-OpenFeign/"},{"title":"TCP与UDP","text":"传输层的作用作为传输层的两个主要协议，为了识别自己传输的数据属于哪个应用，在协议内设定了端口号 将接收和发送的数据与特定的应用程序进行关联起来,通过socket，也就是绑定了端口 区别 TCP 是面向连接的，可靠的的流协议，它提供了可靠性传输，实行顺序控制`重发控制流量控制拥塞控制提高网络利用率`等多种功能 UDP 是不具有可靠性的数据报协议，细微的处理交给上层的应用去完成 TCP头部就不解释每个字段的意思了 TCP的特点通过序列号和确认应答提高可靠性 数据包丢失 数据无法到达 数据应答丢失 重发的超时时间如何确定在BSD的Unix以及Windows系统中，超时都是以0.5s为单位进行控制的，因此重发超时的都是0.5的整数倍，不过由于最初的数据包还不知道往返时间，所以其重发的超时一般设置在6s左右。 连接管理这个会经常提到 TCP以段发送数据在建立TCP连接的同时，也可以确定发送数据包的单位，称为最大消息长度（MSS），TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。 利用窗口控制提高速度TCP以1个段为单位，每发一个段进行一次确认应答，性能太差了，为了解决这个问题。 确认应答不再是以每个分段，而是以更大的单位进行确认，转发的时间被大幅度缩短。也就是说，发送端主机，在发送了一个段以后不必要一直等待确认应答，而是继续发送 窗口控制与重发控制 流控制为了防止流量浪费，比如说，数据接收端在高负荷的情况下无法接受任何数据。如果将本来接受的数据丢弃，则会触发重发机制。 为了防止这种现象，TCP提供了一种机制可以让发送端根据接收端的实际接受能力控制发送的数据量。这就是流控制。 做法就是在TCP首部中，有一个字段来通知窗口的大小，值越大，吞吐量越高 拥塞控制慢启动，慢慢变快 捎带应答 UDP头部","link":"/2019/05/08/TCP与UDP/"},{"title":"gRPC 入门学习","text":"功能gRPC是Google公司开源的一个远程服务调用框架，基于HTTP2协议。 特点 通过接口定义语言(IDL)定义了客户端与服务端数据交换的格式，该文件的扩展名为.proto, 通过将文件编译到对应的开发语言来完成系统的集成。 gRPC使用高效的序列化工具Protocol buffer 在SpringBoot中使用gRPC完成服务间调用完整的代码地址 方法及参数对象声明首先我们需要声明服务调用的接口方法与参数，推荐使用proto3，通过在pom中使用protobuf-maven-plugin插件，可以在编译的时候将.proto文件生成java class文件。 1234567891011121314151617syntax = \"proto3\";option java_multiple_files = true;package com.vcors.demo.grpcproto;message Person { string first_name = 1; string last_name = 2;}message Greeting { string message = 1;}service HelloWorldService { rpc sayHello (Person) returns (Greeting);} 服务端开发理解.proto代码生成 对于.proto文件中定义的对象，会生成对应的JavaClass，这是可以通过Protocal Buffers序列化的对象模型 对于.proto文件中定义的方法，会生成XXXGrpc XXXGrpc 接口方法声明 1public static abstract class HelloWorldServiceImplBase implements io.grpc.BindableService {} 这个抽象内部类主要用来集成在服务端，作为方法实现的父级接口 方法存根 种类分为 XXXBlockingStub blocking-style stub that supports unary and streaming output calls on the service XXXFutureStub ListenableFuture-style stub that supports unary calls on the service XXXStub async stub that supports all call types for the service 方法存根用来集成到客户端，方法客户端调用在服务端实现的方法。 集成依赖在服务端中集成proto模块声明的模型和接口方法 12345&lt;dependency&gt; &lt;groupId&gt;com.vcors.demo&lt;/groupId&gt; &lt;artifactId&gt;grpc-proto&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;&lt;/dependency&gt; 方法实现通过继承HelloWorldServiceGrpc.HelloWorldServiceImplBase来重写.proto接口中声明的方法，也就是具体业务需要实现的逻辑代码都在这 12345678910111213141516171819@GRpcServicepublic class HelloWorldServiceImpl extends HelloWorldServiceGrpc.HelloWorldServiceImplBase { private static final Logger LOGGER = LoggerFactory.getLogger(HelloWorldServiceImpl.class); @Override public void sayHello(Person request, StreamObserver&lt;Greeting&gt; responseObserver) { LOGGER.info(\"server received {}\", request); String message = \"Hello \" + request.getFirstName() + \" \" + request.getLastName() + \"!\"; Greeting greeting = Greeting.newBuilder().setMessage(message).build(); LOGGER.info(\"server responded {}\", greeting); responseObserver.onNext(greeting); responseObserver.onCompleted(); } 客户端调用服务端创建存根接口首先在客户端中也同样要在pom中集成proto声明模块 创建存根方法对象 1234ManagedChannel managedChannel = ManagedChannelBuilder .forAddress(\"localhost\", 6565).usePlaintext().build(); helloWorldServiceBlockingStub = HelloWorldServiceGrpc.newBlockingStub(managedChannel); 执行方法调用像调用本地方法一样，实现不同应用接口的调用 12Greeting greeting = helloWorldServiceBlockingStub.sayHello(person); 测试同时启动服务端与客户端应用，调用客户端接口来收到服务端的正确响应 理解gRPC-spring-boot-startergRPC-spring-boot-starter 是对GRpcServer的一个封装，可以使我们在spring-boot项目中更简单的使用GRpc，核心功能就是启动了GRpcServer，并将通过@GRpcServer注解的Service注册到Server中 理解GRpcAutoConfiguration在grpc-spring-boot-starter/META-INF/spring.factories配置了GRpcAutoConfiguration, springboot启动时会自动加载该配置文件 该文件主要初始化了以下几个Bean实例 GRpcServerRunner HealthStatusManager GRpcServerBuilderConfigurer 理解GRpcServerRunner启动一个GRpc Server, 集成到SpringBoot中后，项目无需再集成其他的web server 123456789101112131415161718192021222324252627public void run(String... args) throws Exception { log.info(\"Starting gRPC Server ...\"); Collection&lt;ServerInterceptor&gt; globalInterceptors = (Collection)this.getBeanNamesByTypeWithAnnotation(GRpcGlobalInterceptor.class, ServerInterceptor.class).map((name) -&gt; { return (ServerInterceptor)this.applicationContext.getBeanFactory().getBean(name, ServerInterceptor.class); }).collect(Collectors.toList()); this.serverBuilder.addService(this.healthStatusManager.getHealthService()); this.getBeanNamesByTypeWithAnnotation(GRpcService.class, BindableService.class).forEach((name) -&gt; { BindableService srv = (BindableService)this.applicationContext.getBeanFactory().getBean(name, BindableService.class); ServerServiceDefinition serviceDefinition = srv.bindService(); GRpcService gRpcServiceAnn = (GRpcService)this.applicationContext.findAnnotationOnBean(name, GRpcService.class); serviceDefinition = this.bindInterceptors(serviceDefinition, gRpcServiceAnn, globalInterceptors); this.serverBuilder.addService(serviceDefinition); String serviceName = serviceDefinition.getServiceDescriptor().getName(); this.healthStatusManager.setStatus(serviceName, ServingStatus.SERVING); log.info(\"'{}' service has been registered.\", srv.getClass().getName()); }); if (this.gRpcServerProperties.isEnableReflection()) { this.serverBuilder.addService(ProtoReflectionService.newInstance()); log.info(\"'{}' service has been registered.\", ProtoReflectionService.class.getName()); } this.configurer.configure(this.serverBuilder); this.server = this.serverBuilder.build().start(); this.applicationContext.publishEvent(new GRpcServerInitializedEvent(this.server)); log.info(\"gRPC Server started, listening on port {}.\", this.server.getPort()); this.startDaemonAwaitThread();} 理解@GRpcService通过该注解声明的方法会被声明为Spring Bean，本质上它是一个@Service注解，另外就是在启动GRpcServer时会注册该Bean。 Next 接口调用的认证处理 结合Kubernetes平台实现服务发现与负载均衡","link":"/2019/05/17/gRPC-入门学习/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/04/24/hello-world/"},{"title":"理解Function和BiFunction","text":"Function Function作为一个函数式接口，主要方法apply接受一个参数，返回一个值 1234567891011@FunctionalInterfacepublic interface Function&lt;T, R&gt; { /** * Applies this function to the given argument. * * @param t the function argument * @return the function result */ R apply(T t);} 这里需要注意的是定义的范型，这个接口中声明了2个类型，其中T为方法参数类型，R为方法返回类型 同时该接口包含了2个default方法，用来对函数进行组合 1234567891011&lt;!--这个方法用来组合一个函数，被组合的函数先执行，--&gt;default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v));}&lt;!--同样这也用来组合一个函数，区别在于被组合的函数后执行--&gt;default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t));} 使用 上面的例子中声明了2个函数f1和f2，分别使用不同的组合方法。 12345678910@Testpublic void test() { Function&lt;Integer, Integer&gt; f1 = x -&gt; {return x * x;}; Function&lt;Integer, Integer&gt; f2 = x -&gt; {return x + x;}; //（3+3）*（3+3）= 36 System.out.println(f1.compose(f2).apply(3)); //（3*3）+（3*3）=18 System.out.println(f1.andThen(f2).apply(3));} BiFunction BiFunction也是一个函数式接口，和Function接口不同的是，它在接口中声明了3个泛型，其中前两个作为方法参数类型，最后一个作为返回类型 123456789101112@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; { /** * Applies this function to the given arguments. * * @param t the first function argument * @param u the second function argument * @return the function result */ R apply(T t, U u);} 同时在BiFunction接口中定义了一个default方法andThen,用来与Function函数进行组合 使用 定义一个函数实现，然后对BiFunction和Function进行组合 12345678@Testpublic void test() { BiFunction&lt;String, String, String&gt; f1 = (x,y) -&gt; \"world \" + x + y; Function&lt;String, String&gt; f2 = (x) -&gt; \"hello \" + x; System.out.println(f1.apply(\"zhang\", \"san\")); System.out.println(f1.andThen(f2).apply(\"li\", \"si\"));} 其它函数式接口在理解了Function接口之后再去理解这些函数接口道理都是一样的，主要区别在于接口声明中范型的的用法 Supplier这个接口用来生产一个T类型的对象 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; { /** * Gets a result. * * @return a result */ T get();} Consumer这个接口用来消费一个对象，无返回 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; { /** * Performs this operation on the given argument. * * @param t the input argument */ void accept(T t);} Predicate这个接口用来测试一个对象,返回值为一个boolean类型 123456789101112@FunctionalInterfacepublic interface Predicate&lt;T&gt; { /** * Evaluates this predicate on the given argument. * * @param t the input argument * @return {@code true} if the input argument matches the predicate, * otherwise {@code false} */ boolean test(T t);}","link":"/2019/05/20/理解Function和BiFunction/"}],"tags":[{"name":"jenkins","slug":"jenkins","link":"/tags/jenkins/"},{"name":"helm","slug":"helm","link":"/tags/helm/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"springcloud","slug":"springcloud","link":"/tags/springcloud/"},{"name":"network","slug":"network","link":"/tags/network/"},{"name":"grpc","slug":"grpc","link":"/tags/grpc/"},{"name":"java","slug":"java","link":"/tags/java/"}],"categories":[{"name":"DevOps","slug":"DevOps","link":"/categories/DevOps/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"Jenkins","slug":"DevOps/Jenkins","link":"/categories/DevOps/Jenkins/"},{"name":"Network","slug":"Network","link":"/categories/Network/"},{"name":"SpringCloud","slug":"Spring/SpringCloud","link":"/categories/Spring/SpringCloud/"},{"name":"gRPC","slug":"gRPC","link":"/categories/gRPC/"},{"name":"Java","slug":"Java","link":"/categories/Java/"}]}